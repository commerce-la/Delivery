<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>네이버 PDF → 운송장 엑셀 (OCR)</title>

  <!-- pdf.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.min.js"></script>
  <!-- tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <!-- SheetJS -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>

  <style>
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; background:#0f172a; color:#e5e7eb; }
    .wrap { max-width: 1000px; margin:0 auto; padding:24px 16px 40px; }
    h1 { font-size:18px; margin:0 0 8px; }
    p { margin:0 0 14px; color:#cbd5f5; font-size:14px; line-height:1.5; }
    .card { background: rgba(15,23,42,.9); border:1px solid rgba(148,163,184,.35); border-radius:16px; padding:18px; box-shadow:0 20px 40px rgba(0,0,0,.25); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    input[type="file"]{ background:#020617; border:1px solid rgba(148,163,184,.5); color:#e5e7eb; padding:10px; border-radius:12px; }
    button{ background:#2563eb; color:#fff; border:0; border-radius:999px; padding:10px 18px; cursor:pointer; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .pill{ display:inline-block; padding:2px 10px; border-radius:999px; background:rgba(37,99,235,.18); border:1px solid rgba(37,99,235,.35); font-size:12px; color:#cbd5f5; }
    .status{ margin-top:12px; font-size:13px; color:#a5b4fc; min-height:18px; white-space:pre-wrap; }
    .log{ margin-top:14px; padding:12px; background:#020617; border:1px solid rgba(148,163,184,.25); border-radius:12px; max-height:260px; overflow:auto; font-size:12px; color:#e5e7eb; white-space:pre-wrap; }
    .hint{ margin-top:12px; font-size:12px; color:#9ca3af; line-height:1.45; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>네이버 PDF → 운송장(waybill) 엑셀 변환 (OCR)</h1>
    <p>
      네이버 주문내역 PDF(표 형식) 업로드 → OCR → 운송장 엑셀 다운로드.<br/>
      출력 컬럼: <b>받는분성명, 받는분주소(전체, 분할), 받는분전화번호, 받는분기타연락처, 품목명, 수량</b>
    </p>

    <div class="card">
      <div class="row">
        <input id="pdfFile" type="file" accept="application/pdf" />
        <button id="btnConvert" disabled>변환 실행 (엑셀 다운로드)</button>
        <span class="pill" id="pageInfo">페이지: -</span>
      </div>

      <div class="status" id="status"></div>
      <div class="log" id="log"></div>

      <div class="hint">
        • 이 코드는 “주문번호(20으로 시작하는 긴 숫자)”를 기준으로 각 주문 레코드를 분리합니다.<br/>
        • OCR 결과가 조금 틀리면(예: 주문번호 인식 실패) DPI/스케일을 올리거나, 패턴을 추가로 보강하면 됩니다.
      </div>
    </div>
  </div>

  <script>
    // pdf.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.6.82/pdf.worker.min.js";

    const $ = (id) => document.getElementById(id);
    const pdfFile = $("pdfFile");
    const btnConvert = $("btnConvert");
    const statusEl = $("status");
    const logEl = $("log");
    const pageInfoEl = $("pageInfo");

    const WAYBILL_COLUMNS = [
      "받는분성명",
      "받는분주소(전체, 분할)",
      "받는분전화번호",
      "받는분기타연락처",
      "품목명",
      "수량",
    ];

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setStatus(msg) { statusEl.textContent = msg; }
    function clean(s) { return (s ?? "").toString().replace(/\s+/g, " ").trim(); }

    function normalizePhone(s) {
      const v = clean(s).replace(/[^0-9\-]/g, "");
      return v;
    }

    // 네이버 PDF에서 보이는 주문번호: 2026... 처럼 "20"으로 시작하는 긴 숫자
    // OCR 흔들림 대비로 11~14자리 정도 허용
    const RE_ORDERNO = /\b20\d{10,14}\b/;
    const RE_DATE = /\b20\d{2}\.\d{2}\.\d{2}\b/;
    const RE_PHONE = /\b0\d{1,2}-\d{3,4}-\d{4}\b/;
    const RE_POST = /\(\d{5}\)/; // (41953) 같은 우편번호
    const RE_QTY_PAREN = /\(\s*(\d+)\s*개\s*\)/; // (3개)
    const RE_QTY_EA = /\b(\d+)\s*(EA|ea|개)\b/;

    // PDF 페이지 렌더링 -> Canvas
    async function renderPageToCanvas(pdf, pageNo, scale = 2.4) {
      const page = await pdf.getPage(pageNo);
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { alpha:false });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;
      return canvas;
    }

    // OCR (페이지 텍스트)
    async function ocrCanvas(canvas) {
      const { data: { text } } = await Tesseract.recognize(
        canvas,
        "kor+eng",
        {
          logger: (m) => {
            if (m.status && typeof m.progress === "number") {
              setStatus(`OCR: ${m.status} (${Math.round(m.progress*100)}%)`);
            }
          }
        }
      );
      return text || "";
    }

    // ==============
    // 파싱 핵심 로직
    // ==============

    // 1) OCR lines -> 주문번호 기준으로 레코드 분리
    function splitRecords(lines) {
      const records = [];
      let cur = [];

      for (const lnRaw of lines) {
        const ln = clean(lnRaw);
        if (!ln) continue;

        // 주문번호가 등장하면 새 레코드 시작(이전 레코드 flush)
        if (RE_ORDERNO.test(ln)) {
          if (cur.length) records.push(cur);
          cur = [ln];
        } else {
          if (cur.length) cur.push(ln);
        }
      }
      if (cur.length) records.push(cur);
      return records;
    }

    // 2) 레코드(라인 묶음)에서 필드 추출
    function parseRecord(lines) {
      const joined = lines.join(" ");
      const orderNo = (joined.match(RE_ORDERNO) || [""])[0];
      const date = (joined.match(RE_DATE) || [""])[0];

      // 전화번호들(1~2개)
      const phones = [];
      for (const ln of lines) {
        const m = ln.match(RE_PHONE);
        if (m) {
          const p = normalizePhone(m[0]);
          if (p && !phones.includes(p)) phones.push(p);
        }
      }

      // 수량: (n개) 우선, 없으면 nEA/ n개
      let qty = "";
      for (const ln of lines) {
        const m1 = ln.match(RE_QTY_PAREN);
        if (m1) { qty = m1[1]; break; }
      }
      if (!qty) {
        for (const ln of lines) {
          const m2 = ln.match(RE_QTY_EA);
          if (m2) { qty = m2[1]; break; }
        }
      }

      // 받는분성명: "이름(닉네임)" 형태가 많아서 첫 괄호 앞 텍스트를 우선
      // 표의 "수취인(구매자명)" 컬럼에서 보통 이름이 먼저 나옴
      let name = "";
      for (const ln of lines) {
        // 이름 후보: 한글 2~6 + ( ... ) 형태
        const m = ln.match(/^([가-힣]{2,10})\s*\(/);
        if (m) { name = m[1]; break; }
      }
      // 그래도 없으면, 괄호 없이 짧은 한글 이름 라인
      if (!name) {
        for (const ln of lines) {
          if (/^[가-힣]{2,10}$/.test(ln)) { name = ln; break; }
        }
      }

      // 주소: (우편번호) 포함 라인이 가장 강함
      let addr = "";
      for (const ln of lines) {
        if (RE_POST.test(ln)) { addr = ln; break; }
      }
      // 없으면 "시/도" 들어간 긴 라인
      if (!addr) {
        for (const ln of lines) {
          if (/(서울|경기|인천|대전|대구|부산|광주|울산|세종|강원|충북|충남|전북|전남|경북|경남|제주)/.test(ln) && ln.length >= 12) {
            addr = ln;
            break;
          }
        }
      }

      // 품목명: 주문번호/날짜/주소/전화/금액성 라인 제외하고, 가장 긴 상품 라인을 선택
      // 네이버 PDF의 상품명은 길고, "라미에이스 ..." 같은 형태가 많음
      const noise = (s) =>
        RE_ORDERNO.test(s) ||
        RE_DATE.test(s) ||
        RE_PHONE.test(s) ||
        RE_POST.test(s) ||
        /원\b/.test(s) ||                 // 9,700원 같은 금액 라인 제거(혼합될 수 있음)
        /(택배|등기|소포)/.test(s);        // 배송방법 라인 제거

      let item = "";
      const candidates = lines
        .map(clean)
        .filter(s => s && !noise(s))
        .filter(s => s.length >= 10);

      // 상품 후보 중 가장 길고, 주소처럼 보이지 않는 라인 선택
      candidates.sort((a,b)=> b.length - a.length);
      for (const c of candidates) {
        // 주소 키워드가 너무 많으면 제외
        if (/(시|군|구|동|로|길|번길)\b/.test(c) && /(서울|경기|인천|대전|대구|부산|광주|울산|세종|강원|충북|충남|전북|전남|경북|경남|제주)/.test(c)) {
          continue;
        }
        item = c;
        break;
      }

      // 최종 보정: 품목명 = item + " - " + qty + "EA"
      const qtyNum = qty ? String(qty).replace(/\D/g,"") : "";
      const itemOut = (item && qtyNum) ? `${item} - ${qtyNum}EA` : item;

      const phone1 = phones[0] || "";
      const phone2 = phones[1] || "";

      return {
        orderNo,
        date,
        "받는분성명": name,
        "받는분주소(전체, 분할)": addr,
        "받는분전화번호": phone1 || phone2 || "",
        "받는분기타연락처": phone2,
        "품목명": itemOut,
        "수량": qtyNum
      };
    }

    // 3) 전체 OCR lines -> waybill rows 생성
    function buildWaybillRows(allLines) {
      const records = splitRecords(allLines);
      const rows = [];

      for (const rec of records) {
        const parsed = parseRecord(rec);

        // 최소한 주문번호 or 이름 or 주소 중 하나라도 있으면 추가
        if (parsed.orderNo || parsed["받는분성명"] || parsed["받는분주소(전체, 분할)"]) {
          rows.push({
            "받는분성명": parsed["받는분성명"],
            "받는분주소(전체, 분할)": parsed["받는분주소(전체, 분할)"],
            "받는분전화번호": parsed["받는분전화번호"],
            "받는분기타연락처": parsed["받는분기타연락처"],
            "품목명": parsed["품목명"],
            "수량": parsed["수량"],
          });
        }
      }
      return rows;
    }

    // ==============
    // UI
    // ==============
    pdfFile.addEventListener("change", () => {
      logEl.textContent = "";
      setStatus("");
      const file = pdfFile.files?.[0];
      btnConvert.disabled = !file;
      pageInfoEl.textContent = "페이지: -";
      if (file) log(`PDF 선택됨: ${file.name} (${Math.round(file.size/1024)} KB)`);
    });

    btnConvert.addEventListener("click", async () => {
      const file = pdfFile.files?.[0];
      if (!file) return;

      btnConvert.disabled = true;
      logEl.textContent = "";
      setStatus("PDF 로딩 중...");
      log("PDF 로딩 시작");

      try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;

        pageInfoEl.textContent = `페이지: ${pdf.numPages}`;
        log(`페이지 수: ${pdf.numPages}`);

        const allLines = [];

        // 페이지별 OCR
        for (let p = 1; p <= pdf.numPages; p++) {
          setStatus(`페이지 ${p}/${pdf.numPages} 렌더링 중...`);
          log(`페이지 ${p} 렌더링`);
          const canvas = await renderPageToCanvas(pdf, p, 2.6);

          setStatus(`페이지 ${p}/${pdf.numPages} OCR 중...`);
          log(`페이지 ${p} OCR 시작`);
          const text = await ocrCanvas(canvas);

          const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          log(`페이지 ${p} OCR 라인: ${lines.length}개`);
          allLines.push(...lines);
        }

        // 파싱 → waybill rows
        setStatus("주문 레코드 파싱 중...");
        log("주문번호 기준 레코드 분리/파싱 시작");
        const rows = buildWaybillRows(allLines);

        log(`추출된 행 수: ${rows.length}`);
        if (!rows.length) {
          setStatus("추출된 행이 없습니다. (주문번호 인식 실패 가능) 로그를 확인하세요.");
          log("힌트: 주문번호 패턴(RE_ORDERNO)을 더 넓히거나, 스케일을 올려보세요.");
          return;
        }

        // 받는분성명 기준 오름차순 정렬(원하면 제거 가능)
        rows.sort((a,b) => (a["받는분성명"]||"").localeCompare((b["받는분성명"]||""), "ko"));

        // 엑셀 생성
        setStatus("엑셀 생성 중...");
        const ws = XLSX.utils.json_to_sheet(rows, { header: WAYBILL_COLUMNS });
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "waybill");

        const outName = file.name.replace(/\.pdf$/i, "") + "_waybill.xlsx";
        XLSX.writeFile(wb, outName, { compression: true });

        setStatus("완료! 엑셀 다운로드가 시작되었습니다.");
        log(`완료: ${outName}`);
      } catch (err) {
        console.error(err);
        setStatus("오류가 발생했습니다. 로그/콘솔을 확인하세요.");
        log(`오류: ${err?.message || err}`);
      } finally {
        btnConvert.disabled = false;
      }
    });
  </script>
</body>
</html>
