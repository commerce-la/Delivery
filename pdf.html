<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PDF → 운송장(waybill) 엑셀 변환 (OCR)</title>

  <!-- ✅ 브라우저용 번들(UMD) -->
  <script defer src="./libs/tesseract/tesseract.min.js"></script>
  <script defer src="./libs/xlsx/xlsx.full.min.js"></script>

  <style>
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; background:#0f172a; color:#e5e7eb; }
    .wrap { max-width: 1100px; margin:0 auto; padding:24px 16px 40px; }
    h1 { font-size:18px; margin:0 0 8px; }
    p { margin:0 0 14px; color:#cbd5f5; font-size:14px; line-height:1.5; }
    .card { background: rgba(15,23,42,.9); border:1px solid rgba(148,163,184,.35); border-radius:16px; padding:18px; box-shadow:0 20px 40px rgba(0,0,0,.25); }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center; }
    input[type="file"]{ background:#020617; border:1px solid rgba(148,163,184,.5); color:#e5e7eb; padding:10px; border-radius:12px; }
    button{ background:#2563eb; color:#fff; border:0; border-radius:999px; padding:10px 18px; cursor:pointer; }
    button:disabled{ opacity:.55; cursor:not-allowed; }
    .btn-secondary{ background:#334155; }
    .pill{ display:inline-block; padding:2px 10px; border-radius:999px; background:rgba(37,99,235,.18); border:1px solid rgba(37,99,235,.35); font-size:12px; color:#cbd5f5; }
    .status{ margin-top:10px; font-size:13px; color:#a5b4fc; min-height:18px; white-space:pre-wrap; }
    .log{ margin-top:14px; padding:12px; background:#020617; border:1px solid rgba(148,163,184,.25); border-radius:12px; max-height:240px; overflow:auto; font-size:12px; color:#e5e7eb; white-space:pre-wrap; }
    .hint{ margin-top:12px; font-size:12px; color:#9ca3af; line-height:1.45; }
    .grid { margin-top:14px; display:grid; grid-template-columns: 1fr 360px; gap:14px; }
    @media (max-width: 980px) { .grid { grid-template-columns: 1fr; } }
    .panel { background:#020617; border:1px solid rgba(148,163,184,.25); border-radius:14px; padding:12px; }
    .panel h3 { margin:0 0 10px; font-size:13px; color:#cbd5f5; }
    .thumbs { display:grid; grid-template-columns: repeat(2, 1fr); gap:10px; }
    .thumb { border:1px solid rgba(148,163,184,.25); border-radius:12px; overflow:hidden; background:#0b1220; }
    .thumb canvas { width:100%; height:auto; display:block; }
    .thumb .cap { padding:8px; font-size:12px; color:#9ca3af; display:flex; justify-content:space-between; }
    .progress-wrap { margin-top:12px; }
    .bar { background:#1e293b; border-radius:999px; height:10px; overflow:hidden; border:1px solid rgba(148,163,184,.25); }
    .bar > div { height:100%; width:0%; background:#38bdf8; transition:width .2s; }
    .ptext { font-size:12px; color:#a5b4fc; margin-top:6px; }
    .kv { margin-top:10px; font-size:12px; color:#9ca3af; display:flex; gap:10px; flex-wrap:wrap; }
    .kv b { color:#e5e7eb; font-weight:600; }
    code { color:#e5e7eb; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>PDF → 운송장(waybill) 엑셀 변환 (OCR) v1.0</h1>
    <p>
      PDF 업로드 → 렌더링 & OCR → 레코드 파싱 → 운송장 엑셀 다운로드<br>
      (기본 레코드 경계: 주문번호 “20으로 시작”)
    </p>

    <div class="card">
      <div class="row">
        <input id="pdfFile" type="file" accept="application/pdf" />
        <button id="btnConvert" disabled>변환 실행 (엑셀 다운로드)</button>
        <button id="btnCancel" class="btn-secondary" disabled>취소</button>
        <button id="btnSaveText" class="btn-secondary" disabled>OCR 텍스트 저장</button>
        <span class="pill" id="libInfo">라이브러리: 확인 중...</span>
        <span class="pill" id="pageInfo">페이지: -</span>
        <span class="pill" id="stageInfo">단계: -</span>
      </div>

      <div class="progress-wrap">
        <div class="bar"><div id="progressBar"></div></div>
        <div class="ptext" id="progressText">전체 진행률: 0%</div>
      </div>

      <div class="status" id="status"></div>

      <div class="grid">
        <div>
          <div class="panel">
            <h3>실시간 로그</h3>
            <div class="log" id="log"></div>
          </div>

          <div class="hint">
            • 값이 엉망이면 <b>OCR 텍스트 저장</b>으로 원문을 확인해 파싱 규칙을 더 고정하세요.<br>
            • 첫 실행은 OCR 언어 데이터 로딩 때문에 시간이 더 걸릴 수 있습니다.<br>
            • 결과는 “받는분성명” 기준 오름차순 정렬 후 다운로드합니다.
          </div>
        </div>

        <div class="panel">
          <h3>페이지 미리보기(썸네일)</h3>
          <div class="thumbs" id="thumbs"></div>
          <div class="kv">
            <span><b>OCR 언어</b>: kor+eng</span>
            <span><b>렌더 스케일</b>: <code id="scaleLabel"></code></span>
            <span><b>썸네일</b>: 저해상도</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- ✅ pdf.js는 ESM으로 import -->
  <script type="module">
    import * as pdfjsLib from "./libs/pdfjs/pdf.mjs";

    // ===== UI =====
    const $ = (id) => document.getElementById(id);
    const pdfFile = $("pdfFile");
    const btnConvert = $("btnConvert");
    const btnCancel = $("btnCancel");
    const btnSaveText = $("btnSaveText");
    const statusEl = $("status");
    const logEl = $("log");
    const pageInfoEl = $("pageInfo");
    const stageInfoEl = $("stageInfo");
    const progressBarEl = $("progressBar");
    const progressTextEl = $("progressText");
    const thumbsEl = $("thumbs");
    const libInfoEl = $("libInfo");
    const scaleLabelEl = $("scaleLabel");

    function log(msg) {
      const time = new Date().toLocaleTimeString();
      logEl.textContent += `[${time}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }
    function setStatus(msg) { statusEl.textContent = msg; }
    function setStage(msg) { stageInfoEl.textContent = `단계: ${msg}`; }
    function setOverallProgress(pct) {
      const v = Math.max(0, Math.min(100, pct));
      progressBarEl.style.width = v.toFixed(1) + "%";
      progressTextEl.textContent = `전체 진행률: ${v.toFixed(1)}%`;
    }

    // ===== Progress segments =====
    const STAGE = {
      LOAD:   { base: 0,  span:  5 },
      THUMB:  { base: 5,  span: 15 },
      RENDER: { base: 20, span: 10 },
      OCR:    { base: 30, span: 60 },
      PARSE:  { base: 90, span:  5 },
      XLSX:   { base: 95, span:  5 },
    };
    function setProgressSegment(stage, local01) {
      const s = STAGE[stage];
      const v = s.base + s.span * Math.max(0, Math.min(1, local01));
      setOverallProgress(v);
    }

    // ===== Config =====
    const OCR_RENDER_SCALE = 3.0;  // 정확도↑(속도↓). 엉망이면 3.0~3.3 권장
    const THUMB_SCALE = 0.7;
    scaleLabelEl.textContent = OCR_RENDER_SCALE.toFixed(1);

    // ✅ worker 경로는 절대경로로 고정 (너의 Pages가 /Delivery/... 인 경우)
    pdfjsLib.GlobalWorkerOptions.workerSrc = "/Delivery/libs/pdfjs/pdf.worker.mjs";

    // ===== State =====
    let cancelRequested = false;
    let totalPages = 0;
    let currentPage = 0;
    let lastOcrText = "";

    function resetUI() {
      cancelRequested = false;
      totalPages = 0;
      currentPage = 0;
      lastOcrText = "";
      logEl.textContent = "";
      setStatus("");
      setStage("-");
      pageInfoEl.textContent = "페이지: -";
      setOverallProgress(0);
      thumbsEl.innerHTML = "";
      btnSaveText.disabled = true;
    }
    function ensureNotCancelled() {
      if (cancelRequested) throw new Error("사용자가 취소했습니다.");
    }

    // ===== Parsing helpers =====
    const RE_ORDERNO = /\b20\d{10,14}\b/;
    const RE_ORDERNO_LINE = /^20\d{10,14}\b/;
    const RE_DATE = /\b20\d{2}\.\d{2}\.\d{2}\b/;
    const RE_POST = /\(\d{5}\)/;
    const RE_NAME_PAREN = /^(.{2,30})\((.{2,30})\)$/; // 이태희(이태희)
    const RE_PHONE_WIDE = /\b0\d{1,3}-\d{3,4}-\d{4}\b/g; // 0502 포함
    const RE_QTY_PAREN_KAE = /\(\s*(\d{1,4})\s*개\s*\)/; // (3개)
    const RE_QTY_PAREN_ANY = /\(\s*(\d{1,4})\s*\)/;     // (37)
    const RE_QTY_EA = /\b(\d{1,4})\s*(EA|ea|개)\b/;

    function clean(s) { return (s ?? "").toString().replace(/\s+/g, " ").trim(); }
    function normalizePhone(s) { return clean(s).replace(/[^0-9\-]/g, ""); }

    function isNoiseLine(s) {
      s = clean(s);
      return !s ||
        RE_ORDERNO.test(s) ||
        RE_DATE.test(s) ||
        RE_POST.test(s) ||
        /원\b/.test(s) ||
        /(택배|등기|소포|선결제|무료|서비스|번호|주문번호|배송방법|수취인|배송지|합계|결제|송장|운송장)/.test(s);
    }

    function splitRecords(lines) {
      const records = [];
      let cur = [];
      for (const lnRaw of lines) {
        const ln = clean(lnRaw);
        if (!ln) continue;
        if (RE_ORDERNO.test(ln)) {
          if (cur.length) records.push(cur);
          cur = [ln];
        } else {
          if (cur.length) cur.push(ln);
        }
      }
      if (cur.length) records.push(cur);
      return records;
    }

    // 주문번호 라인에서 품목/상품 추출(가장 정확한 편)
    function extractItemFromOrderLine(lines) {
      const L = lines.map(clean).filter(Boolean);
      for (const s of L) {
        if (RE_ORDERNO_LINE.test(s)) {
          // 주문번호 제거
          let after = s.replace(RE_ORDERNO_LINE, "").trim();
          // 앞의 상품코드(숫자들) 제거: "3460306489," 같은 것
          after = after.replace(/^\d{6,}\s*,?\s*/, "");
          // 가격 이후 제거
          after = after.replace(/\s+\d[\d,]*원.*$/,"").trim();
          // 너무 짧으면 무시
          if (after.length >= 4) return after;
        }
      }
      return "";
    }

    // 우편번호 라인에서 name/addr 분해
    function extractNameAddrFromPostalLine(line) {
      const s = clean(line);
      const m = s.match(/\(\d{5}\)/);
      if (!m) return { name: "", addr: "" };

      const idx = s.indexOf(m[0]);
      const prefix = clean(s.slice(0, idx));
      const addr = clean(s.slice(idx));

      let name = prefix
        .replace(/[_\-–—]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();

      if (name.includes("(")) name = clean(name.split("(")[0]);

      if (!name || name.length < 2 || /[0-9]/.test(name)) name = "";
      // 너무 길면 잘라서 오탐 방지
      if (name.length > 25) name = name.slice(0, 25).trim();

      return { name, addr };
    }

    // 우편번호 줄 주변(±2줄)에서 이름 찾기(이태희(이태희) 등)
    function extractNameNearPostal(lines) {
      const L = lines.map(clean).filter(Boolean);
      for (let i = 0; i < L.length; i++) {
        if (!RE_POST.test(L[i])) continue;

        // 1) 우편번호 줄 prefix에서 이름 시도
        const r = extractNameAddrFromPostalLine(L[i]);
        if (r.name) return r.name;

        // 2) 주변에서 "이름(이름)" 패턴
        const around = [i-2, i-1, i+1, i+2].filter(x => x >= 0 && x < L.length);
        for (const k of around) {
          const s = L[k];
          const m = s.match(RE_NAME_PAREN);
          if (m) {
            const cand = clean(m[1]);
            if (cand && cand.length >= 2 && !/[0-9]/.test(cand)) return cand;
          }
        }
      }
      return "";
    }

    // fallback 이름 후보
    function pickBestName(lines) {
      const L = lines.map(clean).filter(Boolean);

      // 1) "이름(…)" 형태
      for (const s of L) {
        const m = s.match(/^(.{2,20})\s*\(/);
        if (m) {
          const cand = clean(m[1]).replace(/[_\-]+/g, " ").trim();
          if (cand && cand.length >= 2 && !/[0-9]/.test(cand)) return cand;
        }
      }

      // 2) 단독 짧은 텍스트
      for (const s of L) {
        if (s.length >= 2 && s.length <= 25 && !/[0-9]/.test(s) && !RE_ORDERNO.test(s) && !RE_PHONE_WIDE.test(s)) {
          if (!isNoiseLine(s)) return s;
        }
      }
      return "";
    }

    // 주소 추출: (우편번호) 포함 줄 + 다음 줄이 이어붙기면 합치기
    function extractAddr(lines) {
      const L = lines.map(clean).filter(Boolean);
      for (let i = 0; i < L.length; i++) {
        if (!RE_POST.test(L[i])) continue;

        const idx = L[i].indexOf("(");
        let addr = idx >= 0 ? clean(L[i].slice(idx)) : clean(L[i]);

        // 다음 줄이 짧은 주소 이어붙기면 합침(예: "이집")
        if (i + 1 < L.length) {
          const nxt = L[i + 1];
          if (!isNoiseLine(nxt) && nxt.length <= 15 && !nxt.match(RE_PHONE_WIDE) && !RE_ORDERNO.test(nxt)) {
            addr = clean(addr + " " + nxt);
          }
        }
        return addr;
      }

      // fallback: 지역명 포함 긴 줄
      for (const s of L) {
        if (/(서울|경기|인천|대전|대구|부산|광주|울산|세종|강원|충북|충남|전북|전남|경북|경남|제주)/.test(s) && s.length >= 12) {
          return s;
        }
      }
      return "";
    }

    // 전화번호 추출: 한 줄에 여러개도 모두 수집
    function extractPhones(lines) {
      const phones = [];
      for (const ln of lines) {
        const ms = ln.match(RE_PHONE_WIDE);
        if (ms) {
          for (const p of ms) {
            const np = normalizePhone(p);
            if (np && !phones.includes(np)) phones.push(np);
          }
        }
      }
      return phones;
    }

    // 수량 추출: (n개) > (n) > nEA
    function extractQty(lines) {
      const L = lines.map(clean).filter(Boolean);
      let qtyNum = "";

      // 1) (n개)
      for (const ln of L) {
        const m = ln.match(RE_QTY_PAREN_KAE);
        if (m) { qtyNum = m[1]; break; }
      }

      // 2) (n)  (우편번호 5자리 제외 / 너무 큰 숫자 제외)
      if (!qtyNum) {
        for (const ln of L) {
          const m = ln.match(RE_QTY_PAREN_ANY);
          if (m) {
            const n = parseInt(m[1], 10);
            if (n >= 1 && n <= 500) { qtyNum = String(n); break; }
          }
        }
      }

      // 3) 3EA / 3개
      if (!qtyNum) {
        for (const ln of L) {
          const m = ln.match(RE_QTY_EA);
          if (m) { qtyNum = m[1]; break; }
        }
      }

      return qtyNum;
    }

    // 품목 fallback: 키워드 기반 + 마지막 fallback(긴 라인)
    function pickItemLine(lines) {
      const L = lines.map(clean).filter(Boolean);

      const keys = ["상품명", "제품명", "품목", "상품"];
      for (let i = 0; i < L.length; i++) {
        if (keys.some(k => L[i].includes(k))) {
          for (let j = i + 1; j < Math.min(i + 4, L.length); j++) {
            const s = L[j];
            if (s.length >= 6 && !RE_ORDERNO.test(s) && !RE_POST.test(s) && !s.match(RE_PHONE_WIDE)) return s;
          }
        }
      }

      const opt = L.filter(s =>
        /옵션|색상|사이즈|선택/.test(s) &&
        s.length >= 8 &&
        !RE_POST.test(s) &&
        !RE_ORDERNO.test(s) &&
        !s.match(RE_PHONE_WIDE)
      );
      if (opt.length) return opt.sort((a,b)=>b.length-a.length)[0];

      const noise = (s) =>
        RE_ORDERNO.test(s) ||
        RE_DATE.test(s) ||
        RE_POST.test(s) ||
        s.match(RE_PHONE_WIDE) ||
        /원\b/.test(s) ||
        /(택배|등기|소포|배송|CJ|한진|로젠|합계|결제)/i.test(s);

      const cand = L.filter(s => !noise(s) && s.length >= 10).sort((a,b)=>b.length-a.length);
      return cand[0] || "";
    }

    function parseRecord(lines) {
      const phones = extractPhones(lines);
      const qtyNum = extractQty(lines);

      let name = extractNameNearPostal(lines);
      if (!name) name = pickBestName(lines);

      const addr = extractAddr(lines);

      let item = extractItemFromOrderLine(lines);
      if (!item) item = pickItemLine(lines);

      const itemOut = (item && qtyNum) ? `${item} - ${qtyNum}EA` : item;

      return {
        "받는분성명": name,
        "받는분주소(전체, 분할)": addr,
        "받는분전화번호": phones[0] || phones[1] || "",
        "받는분기타연락처": phones[1] || "",
        "품목명": itemOut,
        "수량": qtyNum
      };
    }

    function buildWaybillRows(allLines) {
      const records = splitRecords(allLines);
      const rows = [];

      for (const rec of records) {
        const r = parseRecord(rec);
        // 최소 조건(노이즈 레코드 제거)
        if (r["받는분성명"] || r["받는분주소(전체, 분할)"] || r["품목명"]) {
          rows.push(r);
        }
      }
      return rows;
    }

    // ===== PDF render helpers =====
    async function renderPageToCanvas(pdf, pageNo, scale) {
      const page = await pdf.getPage(pageNo);
      const viewport = page.getViewport({ scale });
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d", { alpha:false });
      canvas.width = Math.floor(viewport.width);
      canvas.height = Math.floor(viewport.height);
      await page.render({ canvasContext: ctx, viewport }).promise;
      return canvas;
    }

    async function makeThumb(pdf, pageNo) {
      const canvas = await renderPageToCanvas(pdf, pageNo, THUMB_SCALE);
      const box = document.createElement("div");
      box.className = "thumb";

      const cap = document.createElement("div");
      cap.className = "cap";
      cap.innerHTML = `<span>Page ${pageNo}</span><span>thumb</span>`;

      box.appendChild(canvas);
      box.appendChild(cap);
      thumbsEl.appendChild(box);
    }

    // ===== OCR =====
    async function ocrCanvas(canvas) {
      ensureNotCancelled();
      const { data: { text } } = await window.Tesseract.recognize(
        canvas,
        "kor+eng",
        {
          logger: (m) => {
            if (typeof m.progress === "number" && totalPages > 0 && currentPage > 0) {
              const perDoc = ((currentPage - 1) + m.progress) / totalPages;
              setProgressSegment("OCR", perDoc);
            } else {
              if (totalPages > 0 && currentPage > 0) {
                setProgressSegment("OCR", (currentPage - 1) / totalPages);
              }
            }
            if (m?.status) {
              const pp = (typeof m.progress === "number") ? ` (${Math.round(m.progress*100)}%)` : "";
              setStatus(`페이지 ${currentPage}/${totalPages} OCR: ${m.status}${pp}`);
            }
          }
        }
      );
      ensureNotCancelled();
      return text || "";
    }

    // ===== Lib check =====
    async function waitForLibs() {
      await new Promise((r) => window.addEventListener("load", r, { once: true }));

      const okPdf = !!pdfjsLib;
      const okTes = typeof window.Tesseract !== "undefined";
      const okXLSX = typeof window.XLSX !== "undefined";

      libInfoEl.textContent = `라이브러리: pdf.js=${okPdf?"OK":"NO"} / tesseract=${okTes?"OK":"NO"} / xlsx=${okXLSX?"OK":"NO"}`;

      if (!okPdf || !okTes || !okXLSX) {
        log("라이브러리 로드 실패: libs 경로/파일명/대소문자를 확인하세요.");
        setStatus("라이브러리 로드 실패: libs 경로/파일명/대소문자를 확인하세요.");
        return false;
      }
      log("라이브러리 로드 완료");
      setStage("대기");
      setStatus("PDF를 선택하고 ‘변환 실행’을 누르세요.");
      return true;
    }

    // ===== Events =====
    pdfFile.addEventListener("change", () => {
      const file = pdfFile.files?.[0];
      btnConvert.disabled = !file;
      if (file) log(`PDF 선택됨: ${file.name} (${Math.round(file.size/1024)} KB)`);
    });

    btnCancel.addEventListener("click", () => {
      cancelRequested = true;
      btnCancel.disabled = true;
      setStage("취소 처리");
      setStatus("취소 요청됨… (현재 작업이 끝나면 중단됩니다)");
      log("사용자가 취소를 눌렀습니다.");
    });

    btnSaveText.addEventListener("click", () => {
      if (!lastOcrText) return;
      const blob = new Blob([lastOcrText], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "raw_ocr.txt";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      log("OCR 텍스트(raw_ocr.txt) 저장 완료");
    });

    btnConvert.addEventListener("click", async () => {
      const file = pdfFile.files?.[0];
      if (!file) return;

      resetUI();
      btnConvert.disabled = true;
      btnCancel.disabled = false;

      try {
        // LOAD
        setStage("PDF 로딩");
        setStatus("PDF 로딩 중...");
        setProgressSegment("LOAD", 0.1);
        log("PDF 로딩 시작");

        const arrayBuffer = await file.arrayBuffer();
        setProgressSegment("LOAD", 0.7);

        const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        totalPages = pdf.numPages;
        pageInfoEl.textContent = `페이지: ${totalPages}`;
        log(`페이지 수: ${totalPages}`);
        setProgressSegment("LOAD", 1.0);
        ensureNotCancelled();

        // THUMB
        setStage("썸네일 생성");
        setStatus("페이지 썸네일 생성 중...");
        log("썸네일 생성 시작");
        for (let p = 1; p <= totalPages; p++) {
          ensureNotCancelled();
          await makeThumb(pdf, p);
          setProgressSegment("THUMB", p / totalPages);
        }
        log("썸네일 생성 완료");

        // RENDER + OCR
        const allLines = [];
        let allText = "";

        for (let p = 1; p <= totalPages; p++) {
          ensureNotCancelled();
          currentPage = p;

          // RENDER
          setStage("페이지 렌더링");
          setStatus(`페이지 ${p}/${totalPages} 렌더링 중...`);
          log(`페이지 ${p} 렌더링 (scale=${OCR_RENDER_SCALE})`);
          setProgressSegment("RENDER", (p - 1) / totalPages);

          const canvas = await renderPageToCanvas(pdf, p, OCR_RENDER_SCALE);
          setProgressSegment("RENDER", p / totalPages);

          // OCR
          setStage("OCR");
          setStatus(`페이지 ${p}/${totalPages} OCR 준비 중...`);
          log(`페이지 ${p} OCR 시작`);
          setProgressSegment("OCR", (p - 1) / totalPages);

          const text = await ocrCanvas(canvas);
          allText += `\n\n===== PAGE ${p} =====\n` + text;

          const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          log(`페이지 ${p} OCR 라인: ${lines.length}개`);
          allLines.push(...lines);

          setProgressSegment("OCR", p / totalPages);
        }

        lastOcrText = allText;
        btnSaveText.disabled = false;
        ensureNotCancelled();

        // PARSE
        setStage("파싱");
        setStatus("레코드 파싱 중...");
        log("주문번호 기준 레코드 파싱 시작");
        setProgressSegment("PARSE", 0.3);

        const rows = buildWaybillRows(allLines);
        log(`추출된 행 수: ${rows.length}`);
        setProgressSegment("PARSE", 1.0);

        if (!rows.length) {
          setStage("실패");
          setStatus("추출된 행이 없습니다. (주문번호 인식 실패 가능) OCR 텍스트 저장으로 원문 확인 후 파싱 규칙을 조정하세요.");
          log("힌트: OCR_RENDER_SCALE을 3.0~3.3으로 올려보세요.");
          return;
        }

        // Sort
        rows.sort((a,b) => (a["받는분성명"]||"").localeCompare((b["받는분성명"]||""), "ko"));

        // XLSX
        setStage("엑셀 생성");
        setStatus("엑셀 생성 중...");
        log("엑셀 생성 시작");
        setProgressSegment("XLSX", 0.4);

        const ws = window.XLSX.utils.json_to_sheet(rows, {
          header: ["받는분성명","받는분주소(전체, 분할)","받는분전화번호","받는분기타연락처","품목명","수량"]
        });

        const wb = window.XLSX.utils.book_new();
        window.XLSX.utils.book_append_sheet(wb, ws, "waybill");

        setProgressSegment("XLSX", 0.85);

        const outName = file.name.replace(/\.pdf$/i, "") + "_waybill.xlsx";
        window.XLSX.writeFile(wb, outName, { compression: true });

        setProgressSegment("XLSX", 1.0);
        setStage("완료");
        setStatus("완료! 엑셀 다운로드가 시작되었습니다.");
        log(`완료: ${outName}`);
      } catch (err) {
        const msg = (err && err.message) ? err.message : String(err);
        if (msg.includes("취소")) {
          setStage("취소됨");
          setStatus("작업이 취소되었습니다.");
          log("작업 취소됨");
        } else {
          setStage("오류");
          setStatus("오류가 발생했습니다. 로그/콘솔을 확인하세요.");
          log(`오류: ${msg}`);
          console.error(err);
        }
      } finally {
        btnConvert.disabled = false;
        btnCancel.disabled = true;
      }
    });

    // ===== Boot =====
    resetUI();
    const ok = await waitForLibs();
    btnConvert.disabled = !ok || !pdfFile.files?.[0];
  </script>
</body>
</html>
